# -*- coding: utf-8 -*-
"""RMLab_V2_Analytics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_e7EnKrMAffuLQb8Vf5N6RHSF_gE56tB

## Import Statements
"""

from pandas_datareader import data as pdr
# ! pip install quantstats --upgrade --no-cache-dir
import quantstats as qs
import fix_yahoo_finance as yf
from scipy.optimize import minimize
from tqdm import tqdm
from scipy.stats import norm
from datetime import datetime
from datetime import date,timedelta
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import os
import statsmodels.api as sm
import numpy as np; np.random.seed(0)
import seaborn as sns; sns.set()

"""## Strategies"""

class ERCRiskParity:
    """
    Simple Equal-Risk Contribution (ERC) portfolio
    """
    def __init__(self):
        pass

    def price_to_log_return(self, timeseries):

        log_return = np.diff(np.log(timeseries), axis=0)
        return log_return

    def calculate_cov_matrix(self, timeseries):
        log_return = self.price_to_log_return(timeseries)
        cov = np.cov(log_return.T)
        return cov

    def portfolio_risk(self, weight, cov):

        total_risk_of_portfolio = np.sqrt(np.dot(np.dot(weight, cov), weight.T))
        return total_risk_of_portfolio

    def marginal_risk_contribution(self, weight, cov):

        ratio = np.dot(cov, weight.T) / self.portfolio_risk(weight, cov)
        risk_contribution = np.multiply(weight.T, ratio)
        return risk_contribution

    def objection_error(self, weight, args):
        cov = args[0]
        risk_target_percent = args[1]
        total_risk_of_portfolio = self.portfolio_risk(weight, cov)
        risk_contribution = self.marginal_risk_contribution(weight, cov)
        risk_target = np.multiply(risk_target_percent, total_risk_of_portfolio)
        error = np.sum(np.square(risk_contribution - risk_target))
        return error

    def get_signal(self, timeseries, initial_weights, risk_target_percent, tol = 1e-10):
        cov = self.calculate_cov_matrix(timeseries)
        constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1.0},
                        {'type': 'ineq', 'fun': lambda x: x})

        optimize_result = minimize(fun=self.objection_error,
                                    x0=initial_weights,
                                    args=[cov, risk_target_percent],
                                    method='SLSQP',
                                    constraints=constraints,
                                    tol=tol,
                                    options={'disp': False})

        weight = optimize_result.x
        return weight

    def get_allocations(self, timeseries, rolling_window = 24):
        allocations = np.zeros(timeseries.shape)*np.nan
        initial_weights = [1 / timeseries.shape[1]] * timeseries.shape[1]
        risk_target_percent = [1 / timeseries.shape[1]] * timeseries.shape[1]
        for i in tqdm(range(rolling_window, timeseries.shape[0])):
            allocations[i,] = self.get_signal(timeseries[i-rolling_window:i+1], initial_weights,
                                                risk_target_percent)

        return allocations

'''
if __name__ == "__main__":
    ERC = ERCRiskParity()

'''

class MVPort:
    """
    Expected Shortfall (CVaR) portfolio
    """
    def __init__(self, rtnM):
        self.rtnM = rtnM

    def price_to_log_return(self, timeseries):

        log_return = np.diff(np.log(timeseries), axis=0)
        return log_return

    def calculate_miu_cov(self, timeseries):
        log_return = self.price_to_log_return(timeseries)
        miu = np.mean(log_return, axis=0)
        cov = np.cov(log_return.T)
        return miu, cov

    def portfolio_std(self,  weight, cov):
        return np.sqrt(np.dot(np.dot(weight, cov), weight.T))

    def objection_error(self, weight, args):
        miu = args[0]
        cov = args[1]
        total_risk_of_portfolio = self.portfolio_std(weight, cov)
        total_return_of_portfolio = (weight*miu).sum()
        error=(self.rtnM.mean()-total_return_of_portfolio*252)/total_risk_of_portfolio/16
        # error=(np.array(rf*252)-total_return_of_portfolio*252)/total_risk_of_portfolio/16
        return error

    def get_signal(self, timeseries, initial_weights, tol = 1e-10):
        miu, cov = self.calculate_miu_cov(timeseries)
        constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1.0},
                        {'type': 'ineq', 'fun': lambda x: x})

        optimize_result = minimize(fun=self.objection_error,
                                    x0=initial_weights,
                                    args=[miu, cov],
                                    method='SLSQP',
                                    constraints=constraints,
                                    tol=tol,
                                    options={'disp': False})

        weight = optimize_result.x
        return weight

    def get_allocations(self, timeseries, rolling_window = 24):
        allocations = np.zeros(timeseries.shape)*np.nan
        initial_weights = [1 / timeseries.shape[1]] * timeseries.shape[1]
        for i in tqdm(range(rolling_window, timeseries.shape[0])):
            allocations[i,] = self.get_signal(timeseries.iloc[i-rolling_window:i+1,], initial_weights)
        return allocations

"""## Data Pre Processing"""

stocks = ["USO","SPY","GLD","VWO","IEF","EMB","lqd","VNQ","MNA","CAD=X","^IRX"]
#oil,sp500,gold,emerging_eq,us_7_10year_bonds,emerging bonds, hy_coroprate, reit etf, Hedge Fund, risk_free (13-week treasury bond), CAD
start = datetime(2010,1,1)
end = datetime(2020,6,1)

data = pdr.get_data_yahoo(stocks, start=start, end=end)
data = data["Adj Close"]
#data=data.dropna()
rf = data.iloc[1:,-1]/252
cad=data.iloc[1:,-2]/252
data = data.iloc[1:,:-2]

returns=data.pct_change().dropna()
clmns='Oil,SPX,Gold,EM EQ,US Bond,EMD,US HY,REIT,Hedge Fund'.split(',')
dataIdx=data.index.values
dataNamed=pd.DataFrame(data.values,index=dataIdx,columns=clmns).dropna()
rtnNamed=dataNamed.pct_change().dropna()

"""## Portfolio Construction"""

class ERCRP:
    """
    Simple Equal-Risk Contribution (ERC) portfolio
    """
    def __init__(self):
        pass

    def price_to_log_return(self, timeseries):
        """
        timeseries: 2099 * 23 numpy ndarray
        return: 2098 * 23 numpy ndarray
        """
        log_return = np.diff(np.log(timeseries), axis=0)
        return log_return

    def calculate_cov_matrix(self, timeseries):
        log_return = self.price_to_log_return(timeseries)
        cov = np.cov(log_return.T)
        return cov

    def portfolio_risk(self, weight, cov):
        """
        weight: 1 * 23 numpy ndarray
        cov: 23 * 23 numpy ndarray
        return a float
        """
        total_risk_of_portfolio = np.sqrt(np.dot(np.dot(weight, cov), weight.T))
        return total_risk_of_portfolio

    def marginal_risk_contribution(self, weight, cov):
        """
        return a 23 * 1 numpy ndarray
        """
        ratio = np.dot(cov, weight.T) / self.portfolio_risk(weight, cov)
        risk_contribution = np.multiply(weight.T, ratio)
        return risk_contribution

    def objection_error(self, weight, args):
        cov = args[0]
        risk_target_percent = args[1]
        total_risk_of_portfolio = self.portfolio_risk(weight, cov)
        risk_contribution = self.marginal_risk_contribution(weight, cov)
        risk_target = np.multiply(risk_target_percent, total_risk_of_portfolio)
        error = np.sum(np.square(risk_contribution - risk_target))
        return error

    def get_signal(self, timeseries, initial_weights, risk_target_percent, tol = 1e-10):
        cov = self.calculate_cov_matrix(timeseries)
        constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1.0},
                        {'type': 'ineq', 'fun': lambda x: x})

        optimize_result = minimize(fun=self.objection_error,
                                    x0=initial_weights,
                                    args=[cov, risk_target_percent],
                                    method='SLSQP',
                                    constraints=constraints,
                                    tol=tol,
                                    options={'disp': False})

        weight = optimize_result.x
        return weight

    def get_allocations(self, timeseries, rolling_window = 24):
        allocations = np.zeros(timeseries.shape)*np.nan
        initial_weights = [1 / timeseries.shape[1]] * timeseries.shape[1]
        risk_target_percent = [1 / timeseries.shape[1]] * timeseries.shape[1]
        for i in tqdm(range(rolling_window, timeseries.shape[0])):
            allocations[i,] = self.get_signal(timeseries[i-rolling_window:i+1], initial_weights,
                                                risk_target_percent)
        return allocations

'''
if __name__ == "__main__":
    ERC = ERCRiskParity()

'''

def Fit_RP(price,tickerEquity,N):
    ERCEquity=ERCRP()
    z=ERCEquity.get_allocations(price[tickerEquity],N)
    wEquity=pd.DataFrame(z,columns=tickerEquity,index=price.index)
    wEquity=wEquity.shift(1)
    wEquity.replace(np.nan,1/len(tickerEquity),inplace=True)
    rtnERCEquity=(wEquity*np.log(price[tickerEquity]).diff()).sum(axis=1)
    #rtnERCEquity=rtnERCEquity.loc[pd.to_datetime('2014-12-31'):]
    nvERCEquity=np.exp(rtnERCEquity.cumsum())
    shpERCEquity=rtnERCEquity.mean()/rtnERCEquity.std()*np.sqrt(252)
    # nvERCEquity.plot()
    # plt.show()
    # print('Return:',rtnERCEquity.mean()*252,'\nStd.:',rtnERCEquity.std()*16,'\nSharpe:',shpERCEquity)
    return [rtnERCEquity,nvERCEquity,wEquity.loc[rtnERCEquity.index]]




def Fit_MSR(rf,dfMix,N):
    MVMix=MVPort(rf.loc[dfMix.index])
    o=MVMix.get_allocations(dfMix.values,N)
    wMix=pd.DataFrame(o,columns=dfMix.columns,index=dfMix.index)
    wMix=wMix.shift(1)
    wMix.replace(np.nan,1/dfMix.shape[1],inplace=True)
    rtnMVOMix=(wMix*np.log(dfMix).diff()).sum(axis=1)
    #rtnMVOMix=rtnMVOMix.loc[pd.to_datetime('2014-12-31'):]
    nvMVOMix=np.exp(rtnMVOMix.cumsum())
    shpMVOMix=(rtnMVOMix-rf.loc[dfMix.index]).mean()/rtnMVOMix.std()*np.sqrt(252)

    # print('Return:',rtnMVOMix.mean()*252,'\nStd.:',rtnMVOMix.std()*16,'\nSharpe:',shpMVOMix)
    return [rtnMVOMix,nvMVOMix,wMix.loc[rtnMVOMix.index]]




tickerEquity=['XLY','XLI','XLF','XLV','XLK','XLP']
# Consumer Discritionary, Industrial, Financial, Health Care,Technology,
# Consumer Staples
tickerCredit=["EMB","HYG",'LQD','MBB']
# EMD, HY, IG, MBS, Loan BKLN not enough history
tickerHedge=["GLD",'IEF']
tickerPE=['PSP','IGF','VNQ']
# PE. Infra, REITs
tickerAlternative=['MNA']
tickerBM=['SPY','HYG']
stocks = tickerEquity+tickerCredit+tickerPE+tickerHedge+tickerAlternative+["SPY","CAD=X","^IRX"]

start = datetime(2010,1,1)
end = datetime(2020,12,12)

price = pdr.get_data_yahoo(stocks, start=start, end=end)
price = price["Adj Close"]
price=price.dropna(how='any')
price = price.drop(columns = ['CAD=X','^IRX'])

rf = price.iloc[1:,-1]/252/100
cad=price.iloc[1:,-2]/252
# price = price.iloc[:,:-2]
cashValue=(1+rf).cumprod()
cashValue=cashValue.fillna(method='bfill')

rtn=np.log(price).diff().dropna()

clmns='EQ1,EQ2,EQ3,EQ4,EQ5,EQ6,CR1,CR2,CR3,CR4,Gold,Bond,PE,Inf,REITs,HF,SPY'.split(',')
dataIdx=price.index.values
priceNamed=pd.DataFrame(price.values,index=dataIdx,columns=clmns).dropna()
rtnNamed=priceNamed.pct_change().dropna()

#Cell 2
rtnBM=(rtn[['SPY','LQD']]*np.array([0.6,0.4])).sum(axis=1)

rtnBM=rtnBM.loc[pd.to_datetime('2015-01-01'):]
nvBM=np.exp(rtnBM.cumsum())
shpBM=rtnBM.mean()/rtnBM.std()*16


#Cell 3
rtnERCEquity,nvERCEquity,wEquity=Fit_RP(price,tickerEquity,1000)
rtnERCCredit,nvERCCredit,wCredit=Fit_RP(price,tickerCredit,1000)
rtnERCPE,nvERCPE,wPE=Fit_RP(price,tickerPE,1000)

dfMix=pd.DataFrame(columns=['Equity','Credit','PE'],index=nvERCCredit.index)
dfMix.Equity=nvERCEquity.values
dfMix.Credit=nvERCCredit.values
dfMix.PE=nvERCPE.values
rtnERCMix,nvERCMix,wMix=Fit_RP(dfMix,dfMix.columns,1000)

weightsAll=pd.concat([(wEquity.T*wMix.Equity.values).T,(wCredit.T*wMix.Credit.values).T,(wPE.T*wMix.PE.values).T],axis=1)
weightsAll=weightsAll*0.8
for i in tickerHedge:
    weightsAll[i]=0.075
weightsAll['MNA']=0.05

activeClm=tickerEquity+tickerCredit+tickerPE+tickerHedge+tickerAlternative
rtnTotal=(weightsAll*rtn.loc[weightsAll.index[1:],activeClm]).sum(axis=1)

shpTotal=rtnTotal.mean()/rtnTotal.std()*16

myMask=[]

asssd=[]
x=2015

for i in range(6):
  asssd.append(date(x+i,4,1))
  asssd.append(date(x+i,10,1))

trialList=list(asssd)
rebalancing=[]

for i in trialList:
  try:
    a= (weightsAll.loc[i])
    rebalancing.append(i)
  except:
    try:
       a= (weightsAll.loc[i+timedelta(days=1)])
       rebalancing.append(i+timedelta(days=1))
    except:
       try:
            a=(weightsAll.loc[i+timedelta(days=2)])
            rebalancing.append(i+timedelta(days=2))
       except:
            try:
                a=(weightsAll.loc[i+timedelta(days=3)])
                rebalancing.append(i+timedelta(days=3))
            except:
                   pass

# weightsAll.index[1156].to_pydatetime().date()
# rebalancing[0]
# weightsAll.index[1156].to_pydatetime().date() == rebalancing[0]

for i in list(weightsAll.index):
    i = i.to_pydatetime().date()
    if i in (rebalancing):
        myMask.append(True)
    else:
        myMask.append(False)


ERCWeight=weightsAll.loc[myMask]

# weightsAll.index.isin(rebalancing).sum()
# ERCWeight.index=asssd[:-1]
# ERCWeight

start=100000
portfolioValue=price.loc[pd.to_datetime('2015-04-01'):pd.to_datetime('2020-06-01')].dropna()
portfolioValue= (portfolioValue[ERCWeight.columns])
price=price[ERCWeight.columns].dropna()
price=price.loc[pd.to_datetime('2015-04-01'):pd.to_datetime('2020-06-01')].dropna()
investment=[]


for i in range(len(ERCWeight)):
  rebalanceDate=ERCWeight.index[i]

  try:
    endDate=ERCWeight.index[i+1] - timedelta(days=1)
  except:
    endDate=date(2020,6,1)

  relevantData=portfolioValue[rebalanceDate:endDate]

  rebalanceDate=relevantData.index[0]
  endDate=relevantData.index[-1]

  moneyAllocated=start*ERCWeight.iloc[i]
  noofUnits=moneyAllocated.divide(price.loc[rebalanceDate])

  portfolioValue[rebalanceDate:endDate]=portfolioValue[rebalanceDate:endDate]*list(noofUnits)


  investment.extend([100000+(i*10000)]*len(portfolioValue[rebalanceDate:endDate]))
  endvalue=portfolioValue.loc[endDate].sum()

  start=10000+endvalue


portfolioValue["Value"]=portfolioValue.sum(axis=1)
portfolioValue["Principal"]=investment
portfolioValue

rebalancing = portfolioValue[~portfolioValue['Principal'].diff().isin([0])].index
portfolioValue["Return"]=portfolioValue["Value"].pct_change()
portfolioValue.loc[list(portfolioValue.loc[portfolioValue.index.isin(rebalancing)][1:].index),'Return']=(portfolioValue.loc[list(portfolioValue.loc[portfolioValue.index.isin(rebalancing)][1:].index),'Value'])/((portfolioValue.shift(1).loc[list(portfolioValue.loc[portfolioValue.index.isin(rebalancing)][1:].index),'Value'])+10000)-1

returnData=portfolioValue.Return.dropna()
fig = plt.figure(figsize=(12,10))
qs.reports.full(returnData)
plt.savefig("report.png")
plt.close
kkk=qs.reports.metrics(returnData)

plt.figure(figsize=(10,5))
labels=list(ERCWeight.columns)
plt.stackplot(list(ERCWeight.index),ERCWeight.values.T,labels=labels)
plt.title("Weights Rebalancing Evolution")
plt.legend()
plt.show()
plt.figure(figsize=(10,5))
temp=portfolioValue[ERCWeight.columns].div(portfolioValue.Value,axis=0)
plt.stackplot(list(portfolioValue.index),temp.T,labels=labels)
plt.title("Exposure by Asset Class")
plt.legend()

plt.figure(figsize=(14,5))
plt.plot(portfolioValue[ERCWeight.columns])
plt.legend(labels=labels)

"""## Risk Model"""

# df = pd.read_csv("https://raw.githubusercontent.com/pulkitgaur22/Robo-Advisor/master/CPI%20%26%20IPI%20%26Tbill.csv?token=AMNHXGG7LI57FUENCJ7XXYC7AOMVM", index_col='DATE')
df = pd.read_csv("MacroData.csv", index_col='DATE')
df = df.loc[df.index>='2000-03-01'].iloc[:-2,:]
df = df.applymap(lambda x:float(x))
credit_risk_premium = (df['BAMLC0A4CBBBEY']-df['BAMLC0A1CAAAEY'])-(df['BAMLC0A4CBBBEY']-df['BAMLC0A1CAAAEY']).shift(1)

inflation = df['CPIAUCSL'].pct_change().dropna()*100*12
Industrial_prod_growth = df['INDPRO'].pct_change().dropna()*100
riskData = pd.DataFrame(inflation).join(Industrial_prod_growth).join(df.iloc[:,2:7])
riskData['CreditPremium'] = credit_risk_premium
riskData.columns = ['Inflation','IndustrialProdGrowth','T-Bill','Oil','Libor','House','Unemploy','CreditPremium']
riskData['Unexpected Inflation'] = (riskData['Inflation']-riskData['Inflation'].shift(1))-(riskData['T-Bill'].shift(1)-riskData['T-Bill'].shift(2))
riskData = riskData.dropna()
riskData = riskData[['IndustrialProdGrowth','Oil','Unemploy','House','CreditPremium','Unexpected Inflation']]

# riskData.head()
# riskData.describe()
#
# riskData.corr()

# from google.colab import drive
# drive.mount('/content/drive')

riskReturns=portfolioValue.Return.dropna()
riskReturns.index = riskReturns.index.map(lambda x:pd.to_datetime(str(x)))
monthlyReturns=riskReturns.groupby([riskReturns.index.year,riskReturns.index.month]).sum()
monthlyReturns.index.names=["Year","Month"]
monthlyReturns=monthlyReturns.reset_index(level=[0,1])
indexList=[]
for i in range(len(monthlyReturns)):
  indexList.append(date(int(monthlyReturns.iloc[i].Year),int(monthlyReturns.iloc[i].Month),1))
monthlyReturns.index=indexList
monthlyReturns.drop(["Year","Month"],axis=1,inplace=True)
monthlyReturns = monthlyReturns.set_index(pd.DatetimeIndex(monthlyReturns.index))

X=riskData.loc["2015-04-01":"2020-03-01"][riskData.columns]
Y=monthlyReturns.loc["2015-04-01":"2020-03-01"]

X = sm.add_constant(X)
model = sm.OLS(Y, X).fit()


# Basic correlogram
sns.pairplot(X.join(Y))
plt.show()

model.summary()

# model.params

def market_econ_regression(factorReturn):
    try:
        riskReturns=factorReturn.Return.dropna()
    except:
        riskReturns=factorReturn
    riskReturns.index = riskReturns.index.map(lambda x:pd.to_datetime(str(x)))
    monthlyReturns=riskReturns.groupby([riskReturns.index.year,riskReturns.index.month]).sum()
    monthlyReturns.index.names=["Year","Month"]
    monthlyReturns=monthlyReturns.reset_index(level=[0,1])
    indexList=[]
    for i in range(len(monthlyReturns)):
      indexList.append(date(int(monthlyReturns.iloc[i].Year),int(monthlyReturns.iloc[i].Month),1))
    monthlyReturns.index=indexList
    monthlyReturns.drop(["Year","Month"],axis=1,inplace=True)
    monthlyReturns = monthlyReturns.set_index(pd.DatetimeIndex(monthlyReturns.index))

    X=riskData.loc["2015-04-01":"2020-03-01"][riskData.columns]
    Y=monthlyReturns.loc["2015-04-01":"2020-03-01"]
    X = sm.add_constant(X)
    model = sm.OLS(Y, X).fit()
    # print(model.summary())
    return model.params

beta_Equity = market_econ_regression(rtnERCEquity)
beta_Credit = market_econ_regression(rtnERCCredit)
beta_PE = market_econ_regression(rtnERCPE)
beta_BM = market_econ_regression(rtnBM)
beta_portfolio = market_econ_regression(portfolioValue)

riskData.sort_values('Unemploy').iloc[:10,:]

# scenario simulation (boostraping)
def boostraping(econ_data,scenario='down'):
    if scenario == 'down':
        samplePool = riskData.sort_values('Unemploy',ascending=0).iloc[:10,:]
        randomSample1 = list(np.random.choice(samplePool.iloc[:,0],3))
        randomSample2 = list(np.random.choice(samplePool.iloc[:,1],3))
        randomSample3 = list(np.random.choice(samplePool.iloc[:,2],3))
        randomSample4 = list(np.random.choice(samplePool.iloc[:,3],3))
        randomSample5 = list(np.random.choice(samplePool.iloc[:,4],3))
        randomSample6 = list(np.random.choice(samplePool.iloc[:,5],3))
        # randomSample7 = list(np.random.choice(samplePool.iloc[:,6],3))
    if scenario == 'up':
        samplePool = riskData.sort_values('Unemploy').iloc[:10,:]
        randomSample1 = list(np.random.choice(samplePool.iloc[:,0],3))
        randomSample2 = list(np.random.choice(samplePool.iloc[:,1],3))
        randomSample3 = list(np.random.choice(samplePool.iloc[:,2],3))
        randomSample4 = list(np.random.choice(samplePool.iloc[:,3],3))
        randomSample5 = list(np.random.choice(samplePool.iloc[:,4],3))
        randomSample6 = list(np.random.choice(samplePool.iloc[:,5],3))
        # randomSample7 = list(np.random.choice(samplePool.iloc[:,6],3))
    # simulatedScenario = pd.DataFrame([randomSample1,randomSample2,randomSample3,randomSample4,randomSample5,randomSample6,randomSample7]).T
    simulatedScenario = pd.DataFrame([randomSample1,randomSample2,randomSample3,randomSample4,randomSample5,randomSample6]).T
    simulatedScenario.columns = econ_data.columns
    return simulatedScenario

downScenario = boostraping(riskData,scenario='down')
upScenario = boostraping(riskData,scenario='up')
downScenario.insert(0,'constant',1)
upScenario.insert(0,'constant',1)

upEquity = np.dot(np.array(upScenario.iloc[:,:7]),np.array(beta_Equity))
upScenario['EQ Estimated Return'] = upEquity
upCredit = np.dot(np.array(upScenario.iloc[:,:7]),np.array(beta_Credit))
upScenario['CR Estimated Return'] = upCredit
upPE = np.dot(np.array(upScenario.iloc[:,:7]),np.array(beta_PE))
upScenario['PE Estimated Return'] = upPE
upBM = np.dot(np.array(upScenario.iloc[:,:7]),np.array(beta_BM))
upScenario['BM Estimated Return'] = upBM
upPortfolio = np.dot(np.array(upScenario.iloc[:,:7]),np.array(beta_portfolio))
upScenario['Portfolio Estimated Return'] = upPortfolio

downEquity = np.dot(np.array(downScenario.iloc[:,:7]),np.array(beta_Equity))
downScenario['EQ Estimated Return'] = downEquity
downCredit = np.dot(np.array(downScenario.iloc[:,:7]),np.array(beta_Credit))
downScenario['CR Estimated Return'] = downCredit
downPE = np.dot(np.array(downScenario.iloc[:,:7]),np.array(beta_PE))
downScenario['PE Estimated Return'] = downPE
downBM = np.dot(np.array(downScenario.iloc[:,:7]),np.array(beta_BM))
downScenario['BM Estimated Return'] = downBM
downPortfolio = np.dot(np.array(downScenario.iloc[:,:7]),np.array(beta_portfolio))
downScenario['Portfolio Estimated Return'] = downPortfolio
upScenario
downScenario

# Risk Exposure
# EQ = portfolioValue.loc[:'2020-06-01'].iloc[:,0:6].sum(axis=1)
# CR = portfolioValue.loc[:'2020-06-01'].iloc[:,6:10].sum(axis=1)
# Hedge = portfolioValue.loc[:'2020-06-01'].iloc[:,10:13].sum(axis=1)
# PE = portfolioValue.loc[:'2020-06-01'].iloc[:,13:15].sum(axis=1)
# Alternative = portfolioValue.loc[:'2020-06-01'].iloc[:,15].sum()
# pd.DataFrame({'EQ':EQ,'CR':CR,'Hedge':Hedge,'PE':PE,'Alternative':Alternative}).pct_change().dropna().cov()

def getExposure(portfolioValue,date='2020-06-01'):
    w = portfolioValue.loc[date][:-3]/(portfolioValue.loc[date][:-3].sum())
    EQw = w[0:6].sum()
    CRw = w[6:10].sum()
    Hedge_w = w[10:13].sum()
    PE_w = w[13:15].sum()
    Alternative_w = w[15]
    # BM_w = w
    # list of strings
    lst = [EQw, CRw, Hedge_w, PE_w, Alternative_w]
    df = pd.DataFrame(lst, index =['EQ', 'CR', 'Hedge', 'PE', 'Alternative'], columns =['Weight'])
    return df
exposure = getExposure(portfolioValue,'2020-06-01')


# Risk Attribution
def getRiskAttribution(portfolioValue,date='2020-06-01'):
    # portfolioValue = portfolioValue.loc[:date]
    w = getExposure(portfolioValue,date)
    EQ = portfolioValue.loc[:date].iloc[:,0:6].sum(axis=1)
    CR = portfolioValue.loc[:date].iloc[:,6:10].sum(axis=1)
    Hedge = portfolioValue.loc[:date].iloc[:,10:13].sum(axis=1)
    PE = portfolioValue.loc[:date].iloc[:,13:15].sum(axis=1)
    Alternative = portfolioValue.loc[:date].iloc[:,15].sum()
    portfolioValue = pd.DataFrame({'EQ':EQ,'CR':CR,'Hedge':Hedge,'PE':PE,'Alternative':Alternative})
    portfolioReturns = portfolioValue.pct_change().dropna()
    Q = portfolioReturns.cov()
    riskAttribution = np.dot(np.array(w.T),np.array(Q))
    return pd.DataFrame(riskAttribution,columns=['EQ','CR','Hedge','PE','Alternative'])
riskAttribution = getRiskAttribution(portfolioValue,'2020-06-01')


"""# Regime Detection"""

# !pip install hmmlearn
from hmmlearn import hmm
from sklearn.decomposition import PCA
import time
from tqdm import tqdm

def percentile_data(X,period=3,extend=False):
    try:
        start=X.index[0].replace(year=X.index[0].year+period)
    except:
        start=X.index[0].replace(year=X.index[0].year+period,day=28)
    startDate=X.loc[:start].index[-1]
    dfIdx=X.loc[startDate:].index
    dfPercentile=pd.DataFrame(columns=X.columns,index=dfIdx)
    if extend:
        for i in dfIdx:
            dfPercentile.loc[i]=X.loc[:i].rank(pct=True).iloc[-1]
    else:
        for i in dfIdx:
            try:
                dfPercentile.loc[i]=X.loc[i.replace(year=i.year-period):i].rank(pct=True).iloc[-1]
            except:
                dfPercentile.loc[i]=X.loc[i.replace(year=i.year-period,day=28):i].rank(pct=True).iloc[-1]
    return dfPercentile

def fix_states(states, dataHMMTemp):
    tempList=[[0,dataHMMTemp[states==0].mean()]]
    tempList.append([1,dataHMMTemp[states==1].mean()])
    tempList.append([2,dataHMMTemp[states==2].mean()])
    ary=np.array(tempList)[np.argsort(np.array(tempList)[:, 1])]
    return pd.Series(states).replace(ary[:,0],[0,1,2]).values

def desc_by_state(mySeries,states):
    #rtnM=rtnMoney[mySeries.index]
    #descIndex=['Return','Std.','Sharpe','Skewness']
    descIndex=['Return','Std.','Skewness','Kurtosis','Count','T-Count']
    descColumns=['Seeking','Neutral','Aversion']
    df=pd.DataFrame(columns=descColumns,index=descIndex)
    for i in range(3):
        tempSeries=mySeries[states==i]
        df.iloc[0,i]=tempSeries.mean()*252
        df.iloc[1,i]=tempSeries.std()*np.sqrt(252)
        df.iloc[2,i]=tempSeries.skew()
        df.iloc[3,i]=tempSeries.kurtosis()
        df.iloc[4,i]=tempSeries.size
    df.iloc[5,[0,1]]=count_transaction(list(states))
    return df.astype(float).round(5)

def desc_by_threshold(mySeries,riskIndex,threshold=[0,0.25,0.55,1]):
    #rtnM=rtnMoney[mySeries.index]
    #descIndex=['Return','Std.','Sharpe','Skewness']
    descIndex=['Return','Std.','Skewness','Kurtosis','Count']
    descColumns=['Seeking','Neutral','Aversion']
    df=pd.DataFrame(columns=descColumns,index=descIndex)
    for i in range(3):
        tempSeries=mySeries[(riskIndex>threshold[i]) & (riskIndex<=threshold[i+1])]
        df.iloc[0,i]=tempSeries.mean()*252
        df.iloc[1,i]=tempSeries.std()*np.sqrt(252)
        df.iloc[2,i]=tempSeries.skew()
        df.iloc[3,i]=tempSeries.kurtosis()
        df.iloc[4,i]=tempSeries.size
    return df.astype(float).round(5)

def count_transaction(States):
    count=0
    count_half=0
    states=[i/2 for i in States]
    for i in range(len(states)-1):
        temp=states[i+1]-states[i]
        count=count+(temp>0)+(temp<0)
        count_half=abs(temp)+count_half
    return count,count_half


def trade_by_state(mySeries0,states):
    nv=[1]
    cash=1
    pos=0
    if states[0]==0.5:
        cash=0.5
        pos=0.5*(1-0.001)
    elif states[0]==1:
        cash=0
        pos=1-0.001
    nv.append(cash+pos*mySeries0[1]+pos)

    for i in range(1,states.size-1):
        if states[i]-states[i-1]==1:
            pos=cash*(1-0.001)
            cash=0
        elif states[i]-states[i-1]==0.5:
            if pos==0:
                pos=cash/2*(1-0.001)
                cash=cash/2
            else:
                pos=pos+cash*(1-0.001)
                cash=0
        elif states[i]-states[i-1]==-0.5:
            if cash==0:
                cash=pos/2*(1-0.001)
                pos=pos/2
            else:
                cash=cash+pos*(1-0.001)
                pos=0
        elif states[i]-states[i-1]==-1:
            cash=pos*(1-0.001)
            pos=0
        pos=pos*(1+mySeries0.iloc[i+1])
        nv.append(cash+pos)
    return pd.Series([i for i in nv],index=mySeries0.index).astype(float)


def rtn_by_year(rtnSeries):
    yearS=rtnSeries.index[0].year
    yearE=rtnSeries.index[-1].year
    descColumns=['Return','Std.','Sharpe','Skewness','MDD']
    df=pd.DataFrame(index=range(yearS,yearE+1),columns=descColumns)
    for i in df.index:
        tempData=rtnSeries.loc[rtnSeries.index.year==i]
        df.loc[i,'Return']=tempData.mean()*252
        df.loc[i,'Std.']=tempData.std()*np.sqrt(252)
        if df.loc[i,'Return']==0 or df.loc[i,'Std.']==0:
            df.loc[i,'Sharpe']=0
        else:
            df.loc[i,'Sharpe']=df.loc[i,'Return']/df.loc[i,'Std.']
        df.loc[i,'Skewness']=tempData.skew()
        tempCumValue=np.exp(tempData.cumsum())
        df.loc[i,'MDD']=min([(tempCumValue[j]-tempCumValue[:j].max())/tempCumValue[:j].max() for j in tempCumValue.index])
        #df.loc[i,'']
    df.loc['Overall']=np.nan
    df.iloc[-1,0]=rtnSeries.mean()*252
    df.iloc[-1,1]=rtnSeries.std()*np.sqrt(252)
    df.iloc[-1,2]=df.iloc[-1,0]/df.iloc[-1,1]
    cumValue=np.exp(rtnSeries.cumsum())
    df.iloc[-1,3]=rtnSeries.skew()
    df.iloc[-1,4]=min([(cumValue[j]-cumValue[:j].max())/cumValue[:j].max() for j in cumValue.index])
    return df

dataHMM=pd.read_csv('HMM_data.csv',index_col=0,parse_dates=True)

start = datetime(2008,1,1)
end = datetime(2020,5,31)

#VIX, FX Vol, IR Vol, Term Premium, Credit Spread, TED Spread

print (dataHMM.head())
term_premium = pdr.get_data_yahoo(['^TYX','^IRX'], start=start, end=end)
term_premium = term_premium["Adj Close"]
term_premium = term_premium['^TYX']-term_premium['^IRX']

dataHMM=dataHMM.loc[term_premium.index]
dataHMM.iloc[:,-1]=term_premium.values

dataInput=dataHMM
dataInput_m=dataInput.resample('m').last()
dataNormed1=percentile_data(dataInput,1)

EMIndex1=(dataNormed1*[0.2,0.2,0.2,0.2,0.15,0.05]).sum(axis=1)# 1-year version

model=hmm.GMMHMM(n_components=3, covariance_type="full",random_state= 0)

newStates1=[]
for i in tqdm(range(251,EMIndex1.size+1)):
    dataHMMTemp=EMIndex1.iloc[:i].values.reshape(-1,1)
    states=fix_states(model.fit(dataHMMTemp).predict(dataHMMTemp),EMIndex1.iloc[:i].values)
    newStates1.append(states[-1])

dataHMMInit1=EMIndex1.iloc[:250].values.reshape(-1,1)
modelInit1=model.fit(dataHMMInit1)
stateInit1=fix_states(modelInit1.predict(dataHMMInit1),dataHMMInit1)
updatedStates1=pd.Series(list(stateInit1)+newStates1,index=EMIndex1.index)

rtnEquity=np.exp(price.iloc[:,:3]).diff()

idxValid1=[i for i in EMIndex1.index if i in rtnEquity.index]
rtnEquity=rtnEquity.loc[idxValid1]
rtnEquity['Risk_index']=EMIndex1.loc[rtnEquity.index]
rtnEquity['State']=updatedStates1.loc[rtnEquity.index]
#rtnEquity['State_all_period']=allPeriodStates.loc[rtnEquity.index]
rtnEquity['State_all_period']=0

hmmRiskData=rtnEquity.loc["2015-04-01":"2020-06-01"]
plt.figure(figsize=(15,8))
for i in range(len(hmmRiskData)):
    if (hmmRiskData.iloc[i].State) == 0 :
        plt.axvline(x=hmmRiskData.index[i],color='limegreen')
    elif (hmmRiskData.iloc[i].State) == 1:
        plt.axvline(x=hmmRiskData.index[i],color='khaki')
    else:
        plt.axvline(x=hmmRiskData.index[i],color='tomato')


plt.plot(100*dataNamed.loc["2015-04-01":"2020-06-01"].Gold/dataNamed.loc["2015-04-01"].Gold, color='blue',label="Gold")
plt.plot(100*dataNamed.loc["2015-04-01":"2020-06-01"].Oil/dataNamed.loc["2015-04-01"].Oil, color='brown',label="Oil")
plt.plot(100*dataNamed.loc["2015-04-01":"2020-06-01"]["US Bond"]/dataNamed.loc["2015-04-01"]["US Bond"], color='pink',label="Bond")
plt.plot(100*dataNamed.loc["2015-04-01":"2020-06-01"].SPX/dataNamed.loc["2015-04-01"].SPX, color='black',label="SP500")

plt.legend()
plt.show()

a=[]
for i in range(len(hmmRiskData)-10):

  if hmmRiskData.iloc[i].State==1 and hmmRiskData.iloc[i+1].State==2 and len(hmmRiskData.iloc[i:i+10].State)==10:
    a.append(hmmRiskData.index[i])

a

"""## Scenario Testing/ Stress Testing

# Report Generation
"""



"""
# Dashboard
"""
import dash
from dash.dependencies import Input, Output
import dash_core_components as dcc
import dash_html_components as html
import numpy as np
from pandas_datareader import data as web
from datetime import datetime as dt

# Set up global variables
stockpricedf = 0
financialreportingdf =0
discountrate=0.2
margin = 0.15


# Set up the app
app = dash.Dash(__name__)
server = app.server

app.css.append_css({
    "external_url":"https://codepen.io/chriddyp/pen/bWLwgP.css"
})

def portfolio_construction():
    dictlist=[]
    dictlist.append({'value':'Risk Parity', 'label':'RP'})
    dictlist.append({'value':'Max Sharpe Ratio', 'label':'MSR'})
    dictlist.append({'value':'Mean-Variance Optimization', 'label':'MVO'})
    return dictlist

def test(selected_dropdown_value1,selected_dropdown_value2,selected_dropdown_value3,selected_dropdown_value_mix,risk_limit):
    return "Strategy:" + selected_dropdown_value1 +' & ' +selected_dropdown_value2+' & '+selected_dropdown_value3+' ** '+risk_limit + '     Total:' + selected_dropdown_value_mix

app.layout = html.Div([
    html.Div([
        html.H2("Robo Advisor"),
        html.Img(src="/assets/UofT_logo.png")
    ], className="banner"),

    html.Div([
        html.H2("Risk Tolerance (please enter a volatility restraint)"),
        dcc.Input(id="risk-limit-input", value="0.5", type="text")
        # html.Button(id="submit-button", n_clicks=0, children="Submit")
    ]),

    html.Div([

        html.H2('Sub Class Optimization'),
        # First let users choose stocks
        html.H3('Choose an algorithm for equity class'),
        dcc.Dropdown(
            id='my-dropdown1',
            #options=save_sp500_stocks_info()+save_self_stocks_info(),
            options=portfolio_construction(),
            value='Risk Parity'),
        html.H3('Choose an algorithm for credit class'),
        dcc.Dropdown(
            id='my-dropdown2',
            #options=save_sp500_stocks_info()+save_self_stocks_info(),
            options=portfolio_construction(),
            value='Risk Parity'),
        html.H3('Choose an algorithm for PE class'),
        dcc.Dropdown(
            id='my-dropdown3',
            #options=save_sp500_stocks_info()+save_self_stocks_info(),
            options=portfolio_construction(),
            value='Risk Parity'),
        html.H4('Test Output'),
        html.Table(id = 'my-table'),
        html.P('')],style={'width': '40%', 'display': 'inline-block'}),
        html.Div([
        html.H2('Choose an algorithm for total portfolio'),
        dcc.Dropdown(
            id='mix-dropdown',
            #options=save_sp500_stocks_info()+save_self_stocks_info(),
            options=portfolio_construction(),
            value='Risk Parity'),
        html.P(''),
        html.H2("Performance Analysis"),
        html.Img(src="/assets/stock-icon.png",style={'height': '10%','width': '10%', 'display': 'inline-block'})
        ], style={'width': '55%', 'float': 'right', 'display': 'inline-block'}),

        html.Div([
        html.H2('Risk Model'),

        html.H3("Stress Testing"),
        html.Img(src="/assets/stock-icon.png",style={'height': '10%','width': '10%', 'display': 'inline-block'})
        ], style={'width': '40%', 'display': 'inline-block'})

    ])



# For the stocks graph
# @app.callback(Output('my-graph', 'figure'), [Input('my-dropdown', 'value')])
# def update_graph(selected_dropdown_value):
#     global stockpricedf # Needed to modify global copy of stockpricedf
#     stockpricedf = web.DataReader(
#         selected_dropdown_value.strip(), data_source='yahoo',
#         start=dt(2013, 1, 1), end=dt.now())
#     return {
#         'data': [{
#             'x': stockpricedf.index,
#             'y': stockpricedf.Close
#         }]
#     }


# for the table
@app.callback(Output('my-table', 'children'),
            [Input('my-dropdown1', 'value'),
             Input('my-dropdown2','value'),
             Input('my-dropdown3','value'),
             Input('mix-dropdown','value'),
             Input("risk-limit-input",'value')])
def generate_table(selected_dropdown_value1,selected_dropdown_value2,selected_dropdown_value3,selected_dropdown_value_mix,risk_limit):
    # global financialreportingdf # Needed to modify global copy of financialreportingdf
    test_v = test(selected_dropdown_value1,selected_dropdown_value2,selected_dropdown_value3,selected_dropdown_value_mix,risk_limit)

    # Header
    # return [html.Tr([html.Th(col) for col in financialreportingwritten.columns])] + [html.Tr([
    #     html.Td(financialreportingwritten.iloc[i][col]) for col in financialreportingwritten.columns
    # ]) for i in range(min(len(financialreportingwritten), max_rows))]
    return [html.Tr(html.Th(test_v))]




if __name__ == '__main__':
    app.run_server(debug=False)
